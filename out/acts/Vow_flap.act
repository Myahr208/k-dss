behaviour flap of Vow
interface flap()

types

    Cow      : address Flappy
    Vat      : address VatLike
    Bump     : uint256
    Hump     : uint256
    Woe      : uint256
    Ash      : uint256
    DaiMove  : address DaiMoveLike
    Can      : uint256
    Bid_was  : uint256
    Lot_was  : uint256
    Guy_was  : address
    Tic_was  : uint48
    End_was  : uint48
    Gal_was  : address
    Ttl      : uint48
    Tau      : uint48
    Kicks    : uint256
    Can_move : uint256
    Dai      : uint256

storage

    cow  |-> Cow
    vat  |-> Vat
    bump |-> Bump
    hump |-> Hump
    Sin  |-> Sin
    Woe  |-> Woe
    Ash  |-> Ash

storage DaiMove

    vat                         |-> Vat
    can[ACCT_ID][Cow]           |-> Can => Can

storage Cow

    dai                         |-> DaiMove
    ttl_tau                     |-> #WordPackUInt48UInt48(Ttl, Tau)
    kicks                       |-> Kicks   => 1 + Kicks
    bids[1 + Kicks].bid         |-> Bid_was => 0
    bids[1 + Kicks].lot         |-> Lot_was => Bump
    bids[1 + Kicks].guy_tic_end |-> #WordPackAddrUInt48UInt48(Guy_was, Tic_was, End_was) => #WordPackAddrUInt48UInt48(ACCT_ID, Tic_was, TIME + Tau)
    bids[1 + Kicks].gal         |-> Gal_was => ACCT_ID

storage Vat

    wards[DaiMove] |-> Can_move
    dai[ACCT_ID]   |-> Dai => Dai - #Ray * Bump

iff

    // doc: there is enough `Joy`
    Dai / #Ray >= (((Sin + Woe) + Ash) + Bump) + Hump
    // doc: there is no `Woe`
    Woe == 0
    // act: call stack is not too big
    VCallDepth < 1022

iff in range uint48

    TIME + Tau

iff in range uint256

    Sin + Woe
    (Sin + Woe) + Ash
    ((Sin + Woe) + Ash) + Bump
    (((Sin + Woe) + Ash) + Bump) + Hump
    1 + Kicks
    Dai - #Ray * Bump

iff in range int256

     #Ray * Bump

if

    Cow =/= DaiMove
    Cow =/= Vat
    Vat =/= DaiMove
    VGas > 300000

returns 1 + Kicks
