behaviour flop of Vow
interface flop()

types

    Row     : address Flopper
    Vat     : address VatLike
    Ssin    : uint256
    Ash     : uint256
    Sump    : uint256
    Can     : uint256
    Kicks   : uint256
    Vow_was : address
    Lot_was : uint256
    Bid_was : uint256
    Guy_was : address
    Tic_was : uint48
    End_was : uint48
    Ttl     : uint48
    Tau     : uint48
    Dai     : uint256
    Sin_v   : uint256

storage

    row  |-> Row
    vat  |-> Vat
    Sin  |-> Ssin
    Ash  |-> Ash => Ash + Sump
    sump |-> Sump

storage Row

    #Flopper.wards[ACCT_ID]              |-> Can
    #Flopper.kicks                       |-> Kicks => 1 + Kicks
    #Flopper.bids[1 + Kicks].vow         |-> Vow_was => ACCT_ID
    #Flopper.bids[1 + Kicks].bid         |-> Bid_was => Sump
    #Flopper.bids[1 + Kicks].lot         |-> Lot_was => maxUInt256
    #Flopper.bids[1 + Kicks].guy_tic_end |-> #WordPackAddrUInt48UInt48(Guy_was, Tic_was, End_was) => #WordPackAddrUInt48UInt48(ACCT_ID, Tic_was, TIME + Tau)
    #Flopper.ttl_tau                     |-> #WordPackUInt48UInt48(Ttl, Tau)

storage Vat

    dai[ACCT_ID] |-> Dai
    sin[ACCT_ID] |-> Sin_v

iff

    // act: caller is `. ? : not` authorised
    Can == 1
    // doc:
    (Sin_v / #Ray - Ssin) - Ash >= Sump
    // doc: there is at most dust Joy
    Dai < #Ray
    // act: call stack is not too big
    VCallDepth < 1024

iff in range uint48

    TIME + Tau

iff in range uint256

    Ash + Sump
    Sin_v / #Ray - Ssin
    (Sin_v / #Ray - Ssin) - Ash
    1 + Kicks

if

    VGas > 300000

returns 1 + Kicks
