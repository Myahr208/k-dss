behaviour flop of Vow
interface flop()

types

    Row     : address Floppy
    Vat     : address VatLike
    Sump    : uint256
    Woe     : uint256
    Ash     : uint256
    Can     : uint256
    Kicks   : uint256
    Vow_was : address
    Lot_was : uint256
    Bid_was : uint256
    Guy_was : address
    Tic_was : uint48
    End_was : uint48
    Ttl     : uint48
    Tau     : uint48
    Dai     : uint256

storage

    row  |-> Row
    vat  |-> Vat
    sump |-> Sump
    Woe  |-> Woe => Woe - Sump
    Ash  |-> Ash => Ash + Sump

storage Row

    #Flop.wards[ACCT_ID]              |-> Can
    #Flop.kicks                       |-> Kicks => 1 + Kicks
    #Flop.bids[1 + Kicks].vow         |-> Vow_was => ACCT_ID
    #Flop.bids[1 + Kicks].bid         |-> Bid_was => Sump
    #Flop.bids[1 + Kicks].lot         |-> Lot_was => maxUInt256
    #Flop.bids[1 + Kicks].guy_tic_end |-> #WordPackAddrUInt48UInt48(Guy_was, Tic_was, End_was) => #WordPackAddrUInt48UInt48(ACCT_ID, Tic_was, TIME + Tau)
    #Flop.ttl_tau                     |-> #WordPackUInt48UInt48(Ttl, Tau)

storage Vat

    dai[ACCT_ID] |-> Dai

iff

    // act: caller is `. ? : not` authorised
    Can == 1
    // doc: there is at most dust Joy
    Dai < #Ray
    // act: call stack is not too big
    VCallDepth < 1024

iff in range uint48

    TIME + Tau

iff in range uint256

    Woe - Sump
    Ash + Sump
    1 + Kicks

if

    VGas > 300000

returns 1 + Kicks
